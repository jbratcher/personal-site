{
  "date": "2020-05-27T18:03:00.468Z",
  "body": "Recently, I've been developing a lot of projects with [AdonisJS](https://adonisjs.com/) and [Nuxt](https://nuxtjs.org/) so, of course, I've also been working on a starter project that I can just clone and get to work on without worrying about all the initial configuration every time I want to start a new project. My Adonis/Nuxt starter project is built as the base of a general RESTful web application.\r\n\r\nThe majority of these types of apps will at least need some basic user management functionality. Things like being able to authenticate, authorize, and manage users. Both Adonis and Nuxt provide modules that allow you to do all of these things but they aren't pre-installed or pre-configured for the most part.\r\n\r\n### User Management Workflow\r\n\r\nLet's look at a typical user management workflow.\r\n\r\nA user needs to be able to:\r\n\r\n- register\r\n- verify their account\r\n- login\r\n- manage their profile\r\n- logout\r\n- forgot password\r\n- password reset\r\n\r\n### Common Scenarios\r\n\r\nMost use cases need the same basic functionality.\r\n\r\n#### Registration\r\n\r\nThe user fills out and submits a web form. The user's details are used to create a user model instance which is stored in the users table.\r\n\r\n#### Account Verification\r\n\r\nSuccessful registration triggers an email being sent to the user that allows them to verify their account. The email will have a link that contains a token which is linked to the user. The link will redirect the user to a page passing the token as a query parameter. This token is matched against the user's email token in the database token table and is removed after changing the user status to active. Once the account is verified, the user can be authorized for certain permissions.\r\n\r\n#### Login\r\n\r\nWen a user tries to login to the application, their credentials must be verified before we authenticate the user. The entered login credentials are matched against those store in the database. If the credentials match, the user is authenticated.\r\n\r\n#### Profile Management\r\n\r\nA logged in user should be able to view and/or edit their profile. Edits can be biographical information like name, location, or avatar.\r\n\r\n#### Logout\r\n\r\nA logged in user should be able to end their authenticated session by logging out. This should revoke any credential specific to the session that ended such as tokens.\r\n\r\n#### Forgot Password\r\n\r\nA user who has forgotten their password, should be able to submit a request to reset their password. A forgot password form should request the user's unique ID (uid) which can be their email, username, etc. The uid is matched a user in the users table and a token is created to verify the request. An email is then sent to the user with a password reset link containing the token.\r\n\r\n#### Password Reset\r\n\r\nWhen a user clicks a password reset link from their email, they should be redirected to a page to set up a new password. The token in the link will be matched against those in the tokens table to verify the request. The stored password will be updated to reflect the new password that is entered in the web form.\r\n\r\n### Adonis Auth Provider\r\n\r\nAdonis has a built in [authentication provider](https://adonisjs.com/docs/4.0/authentication#_basic_example) that provides a lot of helpful methods and an `auth` object we can pass to our controllers as an extension of the [HTTP Context object](https://adonisjs.com/docs/4.1/request-lifecycle#_http_context)\r\n\r\nThis starter project is pre-configured with [stateless authentication](https://dev.to/yos/stateless-authentication-with-json-web-tokens--km3) using JWT. Adonis has built-in support for [JWT authentication](https://adonisjs.com/docs/4.0/authentication#_jwt) and it is pre-installed on the full-stack version we using.\r\n\r\nTo configure Adonis to use JWT for authentication:\r\n\r\nIn `config/auth.js`:\r\n\r\n```js\r\nmodule.exports = {\r\n  ...\r\n  authenticator: \"jwt\",\r\n  ...\r\n  jwt: {\r\n    serializer: \"lucid\",\r\n    model: \"App/Models/User\",\r\n    scheme: \"jwt\",\r\n    uid: \"email\",\r\n    password: \"password\",\r\n    options: {\r\n      secret: Env.get(\"APP_KEY\")\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n### Adonis Persona\r\n\r\n#### Overview\r\n\r\n[Adonis Persona](https://github.com/adonisjs/adonis-persona) is a service that allows you to easily manage users. It is highly opinionated which is excellent for most use cases as the majority of user management workflows have similar requirements.\r\n\r\n#### Install\r\n\r\nWe will also need to install [Adonis Validator](https://adonisjs.com/docs/4.1/validator) and [Adonis Mail](https://adonisjs.com/docs/4.1/mail) providers. Validator is helpful for validating user input and is required for Persona. Mail helps you configure mail servers, respond to events (like new user registration) and uses Edge templates.\r\n\r\n`npm install @adonisjs/persona @adonisjs/validator`\r\n\r\n#### Configure\r\n\r\nRegister the providers.\r\n\r\nIn `start/app.js`:\r\n\r\n```js\r\nconst providers = [\r\n  \"@adonisjs/mail/providers/MailProvider\",\r\n  \"@adonisjs/persona/providers/PersonaProvider\",\r\n  \"@adonisjs/validator/providers/ValidatorProvider\"\r\n];\r\n```\r\n\r\nPersona requires the `User` and `Token` models to have a relationship set up. By default, the `User` model is already set up correctly but you will need to add a relationship to the `Token` model.\r\n\r\nIn `app/Models/Token.js`:\r\n\r\n```js\r\nclass Token extends Model {\r\n  user() {\r\n    return this.belongsTo(\"App/Models/User\");\r\n  }\r\n}\r\n```\r\n\r\nPersona also requires the `users` table to have a string column named `account_status`. This should be added to your user migration file.\r\n\r\n```js\r\nclass UserSchema extends Schema {\r\n  up() {\r\n    this.create(\"users\", table => {\r\n      ...\r\n      table.string(\"account_status\");\r\n      ...\r\n    });\r\n  }\r\n```\r\n\r\nRe-run the user migration to process the changes to the table if it has already been migrated previously.\r\n\r\n#### Auth routes\r\n\r\nIn `start/routes.js`:\r\n\r\n```js\r\n// Auth\r\nRoute.get(\"/auth/user\", \"UserController.getCurrentUser\");\r\nRoute.post(\"/auth/login\", \"UserController.login\");\r\nRoute.post(\"auth/logout\", \"UserController.logout\");\r\nRoute.post(\"/auth/register\", \"UserController.register\");\r\n```\r\n\r\nNote that all routes except register match the Nuxt auth endpoints.\r\n\r\n#### Controller Methods\r\n\r\nIn the User Controller, we will define the methods we used in our routes file.\r\n\r\nIn `app/Controllers/Http/UserController.js`:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nconst Persona = use(\"Persona\");\r\nconst User = use(\"App/Models/User\");\r\n\r\nclass UserController {\r\n  async getCurrentUser({ auth }) {\r\n    const user = await auth.getUser();\r\n    const token = await auth.getAuthHeader();\r\n    return user;\r\n  }\r\n\r\n  async login({ request, auth, response }) {\r\n    const payload = request.only([\"uid\", \"password\"]);\r\n    const user = await Persona.verify(payload);\r\n    return await auth.generate(user);\r\n  }\r\n\r\n  async logout({ auth }) {\r\n    const user = await auth.getUser();\r\n    const token = await auth.getAuthHeader();\r\n    await user\r\n      .tokens()\r\n      .where(\"token\", token)\r\n      .update({ is_revoked: true });\r\n    return user;\r\n  }\r\n\r\n  async register({ request, auth, response }) {\r\n    const payload = request.only([\r\n      \"email\",\r\n      \"first_name\",\r\n      \"last_name\",\r\n      \"password\",\r\n      \"password_confirmation\"\r\n    ]);\r\n    const { first_name, last_name } = payload;\r\n    payload.full_name = `${first_name} ${last_name}`;\r\n    payload.profile_image_source = `https://ui-avatars.com/api/?name=${first_name}+${last_name}`;\r\n    const user = await Persona.register(payload);\r\n    return await auth.generate(user);\r\n  }\r\n}\r\n```\r\n\r\n`getCurrentUser` is simply returning the current user and ensuring an authentication token exists. This is used in the client to sync the current user data object.\r\n\r\n`login` validates the user's unique ID and password using Persona and returns a token to the client allowing a sync in authentication. The method assumes a unique ID and password are being sent through user input as a request object.\r\n\r\n`logout` is similar to `getCurrentUser` except it also revokes the current user's token then returns the user to sync data with the client.\r\n\r\n`register` uses Persona to create a new user. It expects user input for the fields listed to be sent as a request object. It then transforms the first and last names into the full name and sets a default profile image for the user(this part is can be rmov). Finally, it generates and returns a user token.\r\n\r\n### Nuxt Auth Module\r\n\r\n#### Getting Started\r\n\r\nThe [auth module for Nuxt](https://auth.nuxtjs.org/), which bills itself as \"zero-configuration\", allows you to have client-side authentication which can be synced with the server-side.\r\n\r\nInstall the Nuxt auth module.\r\n\r\n`npm install @nuxtjs/auth`\r\n\r\nRegister the module and set the endpoints in `nuxt.config.js`:\r\n\r\n```js\r\nexport default {\r\n  ...\r\n  modules: [\r\n    \"@nuxtjs/auth\",\r\n  ],\r\n}\r\n/*\r\n** Nuxtjs auth module\r\n*/\r\nauth: {\r\n  strategies: {\r\n    local: {\r\n      endpoints: {\r\n        login: {\r\n          url: \"/auth/login\",\r\n          method: \"post\",\r\n          propertyName: \"token\"\r\n        },\r\n        logout: {\r\n          url: \"/auth/logout\",\r\n          method: \"post\",\r\n          propertyName: \"token\"\r\n        },\r\n        user: { url: \"/auth/user\", method: \"get\", propertyName: false }\r\n      }\r\n      // tokenRequired: true,\r\n      // tokenType: 'bearer',\r\n      // globalToken: true,\r\n      // autoFetchUser: true\r\n    }\r\n  },\r\n  token: {\r\n    prefix: \"token\"\r\n  }\r\n},\r\n```\r\n\r\nNote that I have modified this somewhat from the example in the documentation. Property names were giving me issues when used for the user endpoint so setting it to `false` fixed this issue while still syncing the user data object. The token prefix solved an issue where the token wasn't being updated in Vuex.\r\n\r\n###### Registering this module automatically creates an `auth` module that contains client-side data. Since we are extending the `auth` module, you may be tempted to create a Vuex store module named `auth`. Unfortunately, this may throw a console error that the `auth` namespace is already registered but otherwise work fine. To avoid this error, I have instead put all custom auth methods and properties in the main Vuex store (store/index.js).\r\n\r\nIn `store/index.js`:\r\n\r\n```js\r\nexport const getters = {\r\n  isAuthenticated(state) {\r\n    console.log(`Checking user authentication...`);\r\n    return state.auth.loggedIn;\r\n  },\r\n\r\n  loggedInUser(state) {\r\n    console.log(`Fetching current user info...`);\r\n    return state.auth.user;\r\n  }\r\n};\r\n```\r\n\r\n#### User Actions\r\n\r\nSince the `login` and `register` methods are only used once each on their respective components, they will live in components script instead of the Vuex store.\r\n\r\nI created a `Login.vue` and `Register.vue` at the top level of the `pages` folder.\r\n\r\n`logout` is configured in `nuxt.config.js` as described below.\r\n\r\nNote that I'm using [Vuetify](https://vuetifyjs.com/en/) for UI components.\r\n\r\n##### Login\r\n\r\nIn `Login.vue`:\r\n\r\n```html\r\n<template>\r\n  <v-container>\r\n    <v-row>\r\n      <v-col class=\"d-flex flex-column mx-auto col-9 col-md-6 py-12\">\r\n        <!-- User Login Form -->\r\n        <h1\r\n          :class=\"{\r\n            'display-1 mb-12': $breakpoint.mdAndUp,\r\n            'headline mb-9': $breakpoint.smAndDown\r\n          }\"\r\n        >\r\n          Login\r\n        </h1>\r\n\r\n        <v-text-field\r\n          v-model=\"email\"\r\n          label=\"Email\"\r\n          placeholder=\"Email\"\r\n          :rules=\"emailRules\"\r\n        />\r\n        <v-text-field\r\n          v-model=\"password\"\r\n          label=\"Password\"\r\n          placeholder=\"Password\"\r\n          :rules=\"shortTextRules\"\r\n          type=\"password\"\r\n          autocomplete=\"new-password\"\r\n        />\r\n        <v-alert\r\n          border=\"left\"\r\n          close-text=\"Close\"\r\n          color=\"warning\"\r\n          dark\r\n          dismissible\r\n          :value=\"Boolean(loginErrorMessage)\"\r\n          type=\"error\"\r\n          >{{ loginErrorMessage }}</v-alert\r\n        >\r\n        <v-btn @click=\"login\" dark width=\"fit-content\">\r\n          <v-icon class=\"mr-3\">{{ loginIcon }}</v-icon>Login\r\n        </v-btn>\r\n        <v-btn class=\"body-2 my-6 mr-auto px-0\" to=\"/users/forgot-password\" text\r\n          >Forgot Password?</v-btn\r\n        >\r\n      </v-col>\r\n    </v-row>\r\n  </v-container>\r\n</template>\r\n```\r\n\r\n```js\r\n<script>\r\nimport { mapMutations } from \"vuex\";\r\nimport { mdiLogin } from \"@mdi/js\";\r\nimport formRulesMixin from \"../mixins/formRulesMixin\";\r\nexport default {\r\n  mixins: [formRulesMixin],\r\n  data: () => ({\r\n    loginIcon: mdiLogin,\r\n    email: \"\",\r\n    password: \"\",\r\n    loginErrorMessage: \"\"\r\n  }),\r\n  methods: {\r\n    async login() {\r\n      await this.$auth\r\n        .loginWith(\"local\", {\r\n          data: {\r\n            uid: this.email,\r\n            password: this.password\r\n          }\r\n        })\r\n        .then(response => {\r\n          this.$auth.setToken(\"local\", \"Bearer \" + response.data.token);\r\n          this.$router.replace(\"/\");\r\n        })\r\n        .catch(error => {\r\n          const errorMessage = error.response.data[0].message;\r\n          this.loginErrorMessage = errorMessage;\r\n        });\r\n    }\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\nIn the template, we have input fields for the unqiue ID (uid) and the password which are local data. Clicking the button calls the `login` method which uses the [`loginWith` method](https://auth.nuxtjs.org/api/auth.html#loginwith-strategyname-args) from the Nuxt auth API. This project uses email as the uid but you can add as many others as you need such as 'username'.\r\n\r\n`loginWith` passes the email as the uid and the password to the User Controller via the `login` endpoint set in `nuxt.config.js`. The login method in the User Controller generate and returns a token which is used in the response to set the token client-side. A caught error will set the `loginErrorMessage` local data property which is displayed as an alert on the page.\r\n\r\nAfter logging in the user should be authenticated both client- and server-side.\r\n\r\n##### Register\r\n\r\nIn `Register.vue`:\r\n\r\n```html\r\n<template>\r\n  <v-container>\r\n    <v-row>\r\n      <v-col class=\"d-flex flex-column mx-auto col-9 col-md-6 py-12\">\r\n        <!-- User Sign Up Form -->\r\n        <h1\r\n          :class=\"{\r\n            'display-1 mb-12': $breakpoint.mdAndUp,\r\n            'headline mb-9': $breakpoint.smAndDown\r\n          }\"\r\n        >\r\n          Register\r\n        </h1>\r\n\r\n        <v-text-field\r\n          v-model=\"first_name\"\r\n          label=\"First Name\"\r\n          placeholder=\"First Name\"\r\n        />\r\n        <v-text-field\r\n          v-model=\"last_name\"\r\n          label=\"Last Name\"\r\n          placeholder=\"Last Name\"\r\n        />\r\n        <v-text-field v-model=\"email\" label=\"Email\" placeholder=\"Email\" />\r\n        <v-text-field\r\n          v-model=\"password\"\r\n          label=\"Password\"\r\n          placeholder=\"Password\"\r\n          type=\"password\"\r\n          autocomplete=\"new-password\"\r\n        />\r\n        <v-text-field\r\n          v-model=\"password_confirmation\"\r\n          label=\"Confirm Password\"\r\n          placeholder=\"Confirm Password\"\r\n          type=\"password\"\r\n          autocomplete=\"new-password\"\r\n        />\r\n        <v-alert v-model=\"error\" type=\"error\">{{ errorMessage }}</v-alert>\r\n        <v-btn @click=\"register\" dark width=\"fit-content\">\r\n          <v-icon class=\"mr-3\">{{ accountPlusIcon }}</v-icon>Register\r\n        </v-btn>\r\n        <v-btn class=\"body-2 my-6 mr-auto px-0\" to=\"/login\" text\r\n          >Already registered?</v-btn\r\n        >\r\n      </v-col>\r\n    </v-row>\r\n  </v-container>\r\n</template>\r\n```\r\n\r\n```js\r\n<script>\r\nimport { mdiAccountPlus } from \"@mdi/js\";\r\nexport default {\r\n  data() {\r\n    return {\r\n      accountPlusIcon: mdiAccountPlus,\r\n      first_name: \"\",\r\n      last_name: \"\",\r\n      email: \"\",\r\n      password: \"\",\r\n      password_confirmation: \"\",\r\n      error: false,\r\n      errorMessage: \"\"\r\n    };\r\n  },\r\n  methods: {\r\n    register() {\r\n      try {\r\n        const newUser = {\r\n          email: this.email,\r\n          password: this.password,\r\n          password_confirmation: this.password_confirmation,\r\n          first_name: this.first_name,\r\n          last_name: this.last_name\r\n        };\r\n\r\n        this.$axios\r\n          .post(\"/auth/register\", newUser)\r\n          .then(response => {\r\n            this.login();\r\n          })\r\n          .catch(error => console.log(`Register/login error: ${error}`));\r\n      } catch (e) {\r\n        this.error = true;\r\n        this.errorMessage = e.response.data[0].message;\r\n      }\r\n    },\r\n    login() {\r\n      this.$auth\r\n        .loginWith(\"local\", {\r\n          data: {\r\n            uid: this.email,\r\n            password: this.password\r\n          }\r\n        })\r\n        .then(response => {\r\n          this.$auth.setToken(\"local\", \"Bearer \" + response.data.token);\r\n          this.$router.replace(\"/\");\r\n        })\r\n        .catch(error => console.log(`Login Error: ${error}`));\r\n    }\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\nThe register component is similar to the login component as it is a set of local data fields and a button to submit the data to the User controller. It uses several fields to create the user profile and then logins in the user once successfully registered.\r\n\r\n##### Logout\r\n\r\n`logout` is only defined in the auth object of `nuxt.config.js` on the client-side. We will conditionally display a logout link in the global navigation, that will send a request to the User Controller and call the logout method.\r\n\r\nThis step would complete the minimal viable user module. At this point you can register new users, authenticate them on login and revoke that authentication on logout.\r\n\r\nNext week, we will diving into extending this base functionality to create a more full-featured user module.",
  "title": "User Auth with Adonis and Nuxt",
  "description": "User registration and authentication workflow",
  "thumbnail": "/img/adonis-nuxt-starter.svg",
  "hero": "/img/adonis-nuxt-starter.svg"
}